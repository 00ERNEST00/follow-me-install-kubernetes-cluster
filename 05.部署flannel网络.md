<!-- toc -->

tags: flanneld

# 部署 Flannel 网络

kubernetes 要求集群内各节点能通过 Pod 网段互联互通，本文档介绍在**所有节点** (Master、Node) 上部署和配置 Flannel 的步骤。

Flaneel 启动后，从 etcd 获取 POD 网段信息，为本节点分配一个未使用的 /24 段地址，然后创建 flannedl.1 网络接口，用于节点间 POD 网段互联互通。

同时 Flannel 将分配的 POD 网段信息写入  `/run/flannel/docker` 文件中，本机的 docker 会使用这个文件中参数值设置 docker0 网桥。

## 使用的环境变量

``` bash
[k8s@kube-node1 k8s]$ # 导入用到的其它全局变量：ETCD_ENDPOINTS、FLANNEL_ETCD_PREFIX、CLUSTER_CIDR
[k8s@kube-node1 k8s]$ source /opt/k8s/bin/environment.sh
[k8s@kube-node1 k8s]$
```

## 下载和分发 flanneld 二进制文件

到 [https://github.com/coreos/flannel/releases](https://github.com/coreos/flannel/releases) 页面下载最新版本的发布包：

``` bash
[k8s@kube-node1 k8s]$ mkdir flannel
[k8s@kube-node1 k8s]$ wget https://github.com/coreos/flannel/releases/download/v0.10.0/flannel-v0.10.0-linux-amd64.tar.gz
[k8s@kube-node1 k8s]$ tar -xzvf flannel-v0.10.0-linux-amd64.tar.gz -C flannel
```

分发 flanneld 二进制文件到集群所有节点：

``` bash
[k8s@kube-node1 k8s]$ for node_ip in ${NODE_IPS[@]}
  do
    scp  flannel/{flanneld,mk-docker-opts.sh} k8s@${node_ip}:/opt/k8s/bin/
    ssh k8s@${node_ip} "chmod +x /opt/k8s/bin/{flanneld,mk-docker-opts.sh}"
  done
```

## 创建 flannel 证书签名请求文件

flannel 使用 etcd 集群来存取网段分配信息，而 etcd 集群启用了双向 TLS 认证，所以需要为 flanneld 生成 TLS 证书和私钥。

``` bash
[k8s@kube-node1 k8s]$ cat > flanneld-csr.json <<EOF
{
  "CN": "flanneld",
  "hosts": [],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "BeiJing",
      "L": "BeiJing",
      "O": "k8s",
      "OU": "4Paradigm"
    }
  ]
}
EOF
```
+ flannel 与 etcd 通信时以 client 方式使用该证书，所以无需在 hosts 字段中指定 IP 或列表；

## 生成和分发 flannel 证书和私钥

``` bash
[k8s@kube-node1 k8s]$ cfssl gencert -ca=/etc/kubernetes/ssl/ca.pem \
  -ca-key=/etc/kubernetes/ssl/ca-key.pem \
  -config=/etc/kubernetes/ssl/ca-config.json \
  -profile=kubernetes flanneld-csr.json | cfssljson -bare flanneld
```

生成的证书和私钥：

```
[k8s@kube-node1 k8s]$ ls flanneld*pem
flanneld-key.pem flanneld.pem
```

将生成的证书和私钥分发到**所有节点**（master 和 node）：

``` bash
[k8s@kube-node1 k8s]$ for node_ip in ${NODE_IPS[@]}
  do
    ssh root@${node_ip} "mkdir -p /etc/flanneld/ssl && chown -R k8s /etc/flanneld"
    scp flanneld*.pem k8s@${node_ip}:/etc/flanneld/ssl
  done
```

## 向 etcd 写入集群 Pod 网段信息

注意：本步骤**只需执行一次**。

``` bash
[k8s@kube-node1 k8s]$ etcdctl \
  --endpoints=${ETCD_ENDPOINTS} \
  --ca-file=/etc/kubernetes/ssl/ca.pem \
  --cert-file=/etc/flanneld/ssl/flanneld.pem \
  --key-file=/etc/flanneld/ssl/flanneld-key.pem \
  set ${FLANNEL_ETCD_PREFIX}/config '{"Network":"'${CLUSTER_CIDR}'", "SubnetLen": 24, "Backend": {"Type": "vxlan"}}'
```
+ flanneld **当前版本 (v0.10.0) 不支持 etcd v3**，故使用 etcd v2 API 写入配置 key 和网段数据；
+ 写入的 Pod 网段(${CLUSTER_CIDR}，172.30.0.0/16) 必须与 kube-controller-manager 的 `--cluster-cidr` 参数值一致；

## 创建 flanneld 的 systemd unit 文件

``` bash
[k8s@kube-node1 k8s]$ export IFACE=eth0 # 节点间互联的网络接口名称
[k8s@kube-node1 k8s]$ cat > flanneld.service << EOF
[Unit]
Description=Flanneld overlay address etcd agent
After=network.target
After=network-online.target
Wants=network-online.target
After=etcd.service
Before=docker.service

[Service]
Type=notify
ExecStart=/opt/k8s/bin/flanneld \\
  -etcd-cafile=/etc/kubernetes/ssl/ca.pem \\
  -etcd-certfile=/etc/flanneld/ssl/flanneld.pem \\
  -etcd-keyfile=/etc/flanneld/ssl/flanneld-key.pem \\
  -etcd-endpoints=${ETCD_ENDPOINTS} \\
  -etcd-prefix=${FLANNEL_ETCD_PREFIX} \\
  -iface=${IFACE}
ExecStartPost=/opt/k8s/bin/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/docker
Restart=on-failure

[Install]
WantedBy=multi-user.target
RequiredBy=docker.service
EOF
```
+ mk-docker-opts.sh 脚本将分配给 flanneld 的 Pod 子网网段信息写入到 `/run/flannel/docker` 文件中，后续 docker 启动时使用这个文件中参数值设置 docker0 网桥；
+ flanneld 使用系统缺省路由所在的接口和其它节点通信，对于有多个网络接口的机器（如，内网和公网），可以用 `-iface` 选项值指定通信接口;(本例为 eth0)
+ flanneld 运行时需要 root 权限，用以管理 flannel.1 网络接口；

完整 unit 见 [flanneld.service](https://github.com/opsnull/follow-me-install-kubernetes-cluster/blob/master/systemd/flanneld.service)

## 分发 flanneld systemd unit 文件到**所有节点**

``` bash
[k8s@kube-node1 k8s]$ for node_ip in ${NODE_IPS[@]}
  do
    scp flanneld.service root@${node_ip}:/etc/systemd/system/
  done
```

## 启动 flanneld 服务

``` bash
[k8s@kube-node1 ssl]$ for node_ip in ${NODE_IPS[@]}
  do
    ssh root@${node_ip} "systemctl daemon-reload && systemctl enable flanneld && systemctl start flanneld"
  done
```

## 检查启动结果

``` bash
[k8s@kube-node1 ssl]$ for node_ip in ${NODE_IPS[@]}
  do
    echo ">>> ${node_ip}"
    ssh k8s@${node_ip} "systemctl status flanneld|grep Active"
  done
```

确保状态为 active (running)，否则查看日志，确认原因：

``` bash
[k8s@kube-node1 ssl]$ journalctl -u flanneld
```

## 检查分配给各 flanneld 的 Pod 网段信息

``` bash
[k8s@kube-node1 ssl]$ # 查看集群 Pod 网段(/16)
[k8s@kube-node1 ssl]$ etcdctl \
  --endpoints=${ETCD_ENDPOINTS} \
  --ca-file=/etc/kubernetes/ssl/ca.pem \
  --cert-file=/etc/flanneld/ssl/flanneld.pem \
  --key-file=/etc/flanneld/ssl/flanneld-key.pem \
  get ${FLANNEL_ETCD_PREFIX}/config
{"Network":"172.30.0.0/16", "SubnetLen": 24, "Backend": {"Type": "vxlan"}}

[k8s@kube-node1 ssl]$ # 查看已分配的 Pod 子网段列表(/24)
[k8s@kube-node1 ssl]$ etcdctl \
  --endpoints=${ETCD_ENDPOINTS} \
  --ca-file=/etc/kubernetes/ssl/ca.pem \
  --cert-file=/etc/flanneld/ssl/flanneld.pem \
  --key-file=/etc/flanneld/ssl/flanneld-key.pem \
  ls ${FLANNEL_ETCD_PREFIX}/subnets
/kubernetes/network/subnets/172.30.81.0-24
/kubernetes/network/subnets/172.30.29.0-24
/kubernetes/network/subnets/172.30.39.0-24

[k8s@kube-node1 ssl]$ # 查看某一 Pod 网段对应的 flanneld 进程监听的 IP 和网络参数
[k8s@kube-node1 ssl]$ etcdctl \
  --endpoints=${ETCD_ENDPOINTS} \
  --ca-file=/etc/kubernetes/ssl/ca.pem \
  --cert-file=/etc/flanneld/ssl/flanneld.pem \
  --key-file=/etc/flanneld/ssl/flanneld-key.pem \
  get ${FLANNEL_ETCD_PREFIX}/subnets/172.30.81.0-24
{"PublicIP":"172.27.129.105","BackendType":"vxlan","BackendData":{"VtepMAC":"12:21:93:9e:b1:eb"}}
```

## 验证各节点能通过 Pod 网段互通

在**各节点上部署完** Flannel 后，检查各节点是否创建了 flannedl.1 接口：

``` bash
[k8s@kube-node1 ssl]$ for node_ip in ${NODE_IPS[@]}
  do
    ssh ${node_ip} "/usr/sbin/ip addr show flannel.1|grep -w inet"
  done
```

输出：

``` txt
inet 172.30.81.0/32 scope global flannel.1
inet 172.30.29.0/32 scope global flannel.1
inet 172.30.39.0/32 scope global flannel.1
```

在各节点上分配 ping 上面输出的 IP，确保能通：

``` bash
[k8s@kube-node1 ssl]$ for node_ip in ${NODE_IPS[@]}
  do
    ssh ${node_ip} "ping -c 1 172.30.81.0"
    ssh ${node_ip} "ping -c 1 172.30.29.0"
    ssh ${node_ip} "ping -c 1 172.30.39.0"
  done
```